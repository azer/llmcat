#!/bin/bash
set -eo pipefail

# Default configuration values
CLIP_CMD=""
VERSION="1.0.0"
QUIET="true"
DEBUG="false"
custom_ignores=""
tree_only="false"

# Git integration flags
GIT_DIFF="false"
GIT_ONLY="false"

# Help text
show_help() {
    cat << EOF
llmcat - Prepare files and directories for LLM consumption

Usage: llmcat [options] [path]
       llmcat (interactive mode with fzf)

Options:
    -h, --help              Show this help message
    -v, --version           Show version
    -i, --ignore PATTERN    Additional ignore patterns (grep -E format)
    -t, --tree-only         Only output directory tree
    -q, --quiet             Silent mode (only copy to clipboard)
    -p, --print             Print copied files/content (default: quiet)
    --debug                 Enable debug output
    --git-diff              Append Git diff for each processed file (if tracked)
    --git-only              Limit interactive mode to only changed files (via Git status)

Examples:
    # Interactive file selection
    llmcat

    # Process specific file with Git diff appended (if any)
    llmcat --git-diff path/to/file.txt
EOF
}

# Debug helper
debug() {
    if [ "$DEBUG" = "true" ]; then
        printf "DEBUG: %s\n" "$*" >&2
    fi
}

# Detect OS and set clipboard command
detect_os() {
    case "$(uname)" in
        "Darwin")
            CLIP_CMD="pbcopy"
            command -v pbcopy >/dev/null 2>&1 || {
                echo "Error: pbcopy not found" >&2
                exit 1
            }
            ;;
        "Linux")
            if command -v wl-copy >/dev/null 2>&1; then
                CLIP_CMD="wl-copy"
            elif command -v xclip >/dev/null 2>&1; then
                CLIP_CMD="xclip -selection clipboard"
            elif command -v xsel >/dev/null 2>&1; then
                CLIP_CMD="xsel --clipboard --input"
            else
                echo "Error: Install xclip or xsel for clipboard support" >&2
                exit 1
            fi
            ;;
        *)
            echo "Error: Unsupported OS" >&2
            exit 1
            ;;
    esac
}

# Find git root or current directory
find_root() {
    if git rev-parse --git-dir >/dev/null 2>&1; then
        git rev-parse --show-toplevel
    else
        pwd
    fi
}

# Check for fzf and configure it
setup_fzf() {
    if ! command -v fzf >/dev/null 2>&1; then
        echo "Interactive mode requires fzf. Install with:"
        echo "  brew install fzf    # macOS"
        echo "  apt install fzf     # Ubuntu"
        echo
        show_help
        return 1
    fi
    return 0
}

# Run fzf with support for --git-only filtering and custom ignore patterns
run_fzf() {
    local gitignore_pattern="$1"
    local custom_ignores="$2"
    local root_dir
    root_dir=$(find_root)

    debug "Running fzf from: $root_dir"

    # Preview command to show file contents or directory tree
    local preview_cmd='
        if [ -f {} ]; then
            bat --style=numbers --color=always {} 2>/dev/null
        elif [ -d {} ]; then
            echo "\n  Directory: {}\n"
            tree -C {} 2>/dev/null || ls -la {} 2>/dev/null
        fi'

    # Determine file listing command based on --git-only option
    local find_cmd=""
    if [ "$GIT_ONLY" = "true" ]; then
        if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
            find_cmd="git status --porcelain | awk '{print \$2}'"
        else
            echo "Warning: --git-only specified but not inside a Git repository. Using default file listing." >&2
            find_cmd="find . -type f -o -type d"
        fi
    else
        find_cmd="find . -type f -o -type d"
    fi

    # Append ignore patterns if provided
    [ -n "$gitignore_pattern" ] && find_cmd+=" | grep -Ev \"$gitignore_pattern\""
    [ -n "$custom_ignores" ] && find_cmd+=" | grep -Ev \"$custom_ignores\""

    debug "Find command: $find_cmd"

    (cd "$root_dir" && {
        eval "$find_cmd" | sed 's|^\./||' | fzf \
            --preview "$preview_cmd" \
            --preview-window 'right:60%:border-left' \
            --bind 'ctrl-/:toggle-preview' \
            --bind 'ctrl-d:change-prompt(Select directories > )+reload(find . -type d | sed "s|^./||")' \
            --bind 'ctrl-f:change-prompt(Select files > )+reload(find . -type f | sed "s|^./||")' \
            --bind 'tab:toggle+up' \
            --bind 'shift-tab:toggle+down' \
            --height '80%' \
            --border=rounded \
            --prompt 'âš¡ Select files/dirs > ' \
            --multi \
            --color 'fg+:252,bg+:-1,hl:148,hl+:154,pointer:032,marker:010,prompt:064,border:240,separator:240'
    })
}

# Process file content and optionally append Git diff output
process_file() {
    local file="$1"
    local rel_path
    rel_path=$(echo "$file" | sed "s|$(find_root)/||")
    {
        echo "## File: $rel_path"
        echo "---"
        cat "$file"
        echo
        if [ "$GIT_DIFF" = "true" ] && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
            if git ls-files --error-unmatch "$file" >/dev/null 2>&1; then
                local diff_output
                diff_output=$(git diff "$file" 2>/dev/null)
                if [ -n "$diff_output" ]; then
                    echo "### Git Diff for $rel_path"
                    echo '```diff'
                    echo "$diff_output"
                    echo '```'
                else
                    echo "### No changes in Git for $rel_path"
                fi
            else
                echo "### File not tracked in Git: $rel_path"
            fi
        fi
    }
}

# Process directory content: generate a tree view and process files within
process_dir() {
    local dir="$1"
    local custom_ignores="$2"
    local tree_only="$3"
    local gitignore_pattern=""
    local rel_path
    rel_path=$(echo "$dir" | sed "s|$(find_root)/||")

    [ -f "$dir/.gitignore" ] && gitignore_pattern=$(parse_gitignore "$dir/.gitignore")

    {
        echo "# Directory: $rel_path"
        echo "---"
        echo

        local tree_output
        if command -v tree >/dev/null 2>&1; then
            tree_output=$(cd "$dir" && tree -I "$(echo "$gitignore_pattern" | tr '|' ' ')")
        else
            tree_output=$(find "$dir" -type f -o -type d 2>/dev/null | \
            if [ -n "$gitignore_pattern" ]; then
                grep -Ev "$gitignore_pattern"
            else
                cat
            fi | \
            if [ -n "$custom_ignores" ]; then
                grep -Ev "$custom_ignores"
            else
                cat
            fi | \
            sed -e "s/[^-][^\/]*\// |--/g" -e "s/|\([^ ]\)/|-\1/")
        fi
        echo "$tree_output"

        if [ "$tree_only" != "true" ]; then
            find "$dir" -type f 2>/dev/null | \
            if [ -n "$gitignore_pattern" ]; then
                grep -Ev "$gitignore_pattern"
            else
                cat
            fi | \
            if [ -n "$custom_ignores" ]; then
                grep -Ev "$custom_ignores"
            else
                cat
            fi | \
            while IFS= read -r file; do
                echo
                process_file "$file"
            done
        fi
    }
}

# Parse .gitignore into a regex pattern
parse_gitignore() {
    local gitignore="$1"
    if [ -f "$gitignore" ]; then
        grep -v '^#' "$gitignore" | \
        grep -v '^\s*$' | \
        sed 's/\./\\./g' | \
        sed 's/\*/[^\/]*/g' | \
        tr '\n' '|' | \
        sed 's/|$//'
    fi
}

# Output handling: copy to clipboard and optionally print to stdout
output_handler() {
    local content="$1"
    echo -n "$content" | eval "$CLIP_CMD"
    if [ "$QUIET" = "false" ] || [ "$tree_only" = "true" ]; then
        echo "$content"
    fi
    if [ "$tree_only" != "true" ]; then
        local file_count
        file_count=$(echo "$content" | grep -c "^## File:" || true)
        echo "Copied $file_count file(s) to clipboard" >&2
    fi
}

# Process multiple targets (files and directories)
process_targets() {
    local output=""
    local target

    for target in "$@"; do
        debug "Processing: $target"
        if [ -f "$target" ]; then
            output+="$(process_file "$target")"
        elif [ -d "$target" ]; then
            output+="$(process_dir "$target" "$custom_ignores" "$tree_only")"
        else
            echo "Warning: Target not found - $target" >&2
            continue
        fi
        output+=$'\n\n'
    done

    output_handler "$output"
}

# Main: parse arguments, launch interactive mode if no targets, and process targets
main() {
    local targets=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help) show_help; exit 0 ;;
            -v|--version) echo "llmcat version $VERSION"; exit 0 ;;
            -i|--ignore) custom_ignores="$2"; shift 2 ;;
            -t|--tree-only) tree_only="true"; shift ;;
            -q|--quiet) QUIET="true"; shift ;;
            -p|--print) QUIET="false"; shift ;;
            --debug) DEBUG="true"; shift ;;
            --git-diff) GIT_DIFF="true"; shift ;;
            --git-only) GIT_ONLY="true"; shift ;;
            *) targets+=("$1"); shift ;;
        esac
    done

    detect_os

    # If no targets provided, launch interactive mode
    if [ ${#targets[@]} -eq 0 ]; then
        if setup_fzf; then
            local root_dir
            root_dir=$(find_root)
            local gitignore_pattern=""
            if [ -f "$root_dir/.gitignore" ]; then
                gitignore_pattern=$(parse_gitignore "$root_dir/.gitignore")
                debug "Using gitignore pattern: $gitignore_pattern"
            fi

            local selected
            selected=$(run_fzf "$gitignore_pattern" "$custom_ignores")
            if [ -n "$selected" ]; then
                while IFS= read -r line; do
                    [ -n "$line" ] && targets+=("$line")
                done <<< "$selected"
            else
                exit 0
            fi
        else
            exit 1
        fi
    fi

    if [ ${#targets[@]} -gt 0 ]; then
        process_targets "${targets[@]}"
    fi
}

main "$@"
